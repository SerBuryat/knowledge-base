- [ ] `publishOn` method for assigning job for some `ThreadPool`
- [ ] `WebClient` has "*event loop* style"
- [ ] WebFlux and Reactor concurrency models
- [ ] **==IMHO==** reactive model: 
- request in -> netty-thread send it to event queue -> netty-thread returns to netty's thread pool 
- *event loop* assign handler(worker-thread) for event -> worker faced IO bound task -> worker sent to queue -> worker returns to worker's thread pool
- IO bound sent "ready for process" event (data is coming from DB, REST API etc.)
- *event loop* assign handler(worker-thread) for event -> worker sent response out -> worker returns to worker's thread pool
- [ ] - reactive *event loop* register *callback* via **==platform==** (==*is OS kernel level API*???==), platform check completaion status and trigger worker thread (WebFlux) to continue code via callback - https://www.baeldung.com/spring-webflux-concurrency
- [ ] - reactive programming models
- [ ] - **==one thread==** (usually *event loop*) **==can check (via *endless loop*) for I/O operation==** completion **==instead every thread blocked==** until it (*event-driven systems* based on this approach)
- [ ] - *event-driven systems* divided into parts (*event handlers*) communicated via *events* and *event-queue* (they move events to queue and single thread infinitly check this queue and run event handlers???)
- [ ] - reactive vs *event-driven system* (reactive based on event-driven???)
- [ ] - [Spring WebFlux threading model](https://hackernoon.com/an-intro-to-spring-webflux-threading-model)
- [ ] - [Spring WebFlux Visualized: Threading and EventLoops](https://www.stefankreidel.io/blog/spring-webflux) (well visualized via gifs)
-  The core of *reactive programming* defines, that **instead of waiting for blocking operation (I/O bound) to finish, threads do other things in the meantime and pick up the response after the operation completed**
- *reactive programming* is first and **foremost centered around non-blocking**
- parts of a request can be handled by multiple threads (1st - accept request, 2nd - process, 3rd - complete etc.)
- requests are handled by `EventLoops`. **`EventLoops` are basically just threads** with the addition that **they have to run at all** time (cpu bound jobs)
- once a blocking operation is reached, **`EventLoops` do not wait around for the operation to be finished** (register *callback* which will execute when I/O finishes) but **hand over the execution context** (some 'threadlocal' data ) and are then free to process other requests
- **java NIO is core of non-blocking I/O in Spring WebFlux**
- `EventLoops` to handle many requests **only works** and scales efficiently, **if all blocking operations are implemented reactively**
- for blocking (non reactive impl ops) use `Scheduler` (`publishOn(Schedulers.boundedElastic())`) **it helps don't block `EventLoop` threads** (`Schedulers.boundedElastic()` threads are **more lightweight and intended to be used for blocking operations**)
- for heavy compute steps as the bounded-elastic threads are intended for, use `.publishOn(Schedulers.parallel())` 
- async and non-blocking I/O is two aspects to impl a parallelism
	- non-blocking I/O is I/O complition without blocking *thread* (CPU) via *DMA*/sockets/platform features
	- async is run parallel thread using several CPUs
- [ ] - [Netty brief nutshell](https://baekjungho.github.io/wiki/spring/spring-netty/) - threading model, core concepts and components(+links)
- [ ] - [Performance Comparison — Thread Pool vs. Virtual Threads (Project Loom) In Spring Boot Applications](https://dzone.com/articles/request-handling-approaches-threadpool-webflux-cor) - usefull perfomance graphics
- [ ] - There’s also an initiative to standardize the reactive streams API. The initiative is called [Reactive Streams](https://www.reactive-streams.org/). It defines a set of rules for asynchronous stream processing with non-blocking back pressure.
- [ ] - reactive programming paradigm based on decouple receive events/messages/request/signals and handling/process them in parallel or later. Reactive consists of *async* and *non-blocking* approach where *main thread* **==not blocked==** and **==async event handling==**. **Don't be confused with *non-blocking I/O*(!!!)** this is **just possibility of platform to non-blocking/async I/O processes handling** (via `epoll()`, `wepoll()` etc.)
- [ ] - *Observer pattern* It is often used for implementing distributed [event-handling](https://en.wikipedia.org/wiki/Event_handling "Event handling") systems in [event-driven software](https://en.wikipedia.org/wiki/Event-driven_programming "Event-driven programming")
- *Observer pattern*  and implementations :
	- Observer: **observable has a list of observers and notify them after some state changes**
	- *Publisher-subscriber pattern* is a decoupled variation of Observer: **publisher send a message about state changing into message queue and subscribers gonna notified and poll this message**
	- *Event Emitter/Target/Dispatcher pattern*
	- *Signals pattern*
- [ ] - [ReactiveX](https://reactivex.io/) (Rx) - language agnostic specification of reactive APIs developed by Microsoft
- [ ] - Based on Rx specification  [Reactive Streams](https://github.com/reactive-streams/reactive-streams-jvm) is provider a **standard for asynchronous stream processing** with non-blocking backpressure for Java
- [ ] -  Reactive Streams impls: 
- [RxJava](https://github.com/ReactiveX/RxJava)  developed by Netflix 
- [Project Reactor](https://github.com/reactor/reactor-core)
- Spring Web Flux based on Project Reactor
- [ ] - Flow API is Java's official support for [Reactive Streams Specification](http://www.reactive-streams.org/) (`java.util.concurrent.Flow`) 
- [ ] - Reactive Streams has [FlowAdapters](https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java9/org/reactivestreams/FlowAdapters.java) to implement Flow API after it's introduction
- [ ] - Good *RP* [article](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) and [working Rx JS example](https://jsfiddle.net/staltz/8jFJH/48/) (sandbox)
- [ ] - *RP* is just a way to manage of async data streams **???** 
> *The main goal of Reactive Streams is to* **govern the exchange of stream data across an asynchronous boundary**
> Multiple async operations linked in a chain and managed in some way - Reactive Programming **???**

- [ ] - The [Reactor Pattern](https://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf) utilizes an intermediary service handler which demultiplexes requests and dispatches to the correct handler.
- [ ] - The [Observer Pattern](https://en.wikipedia.org/wiki/Observer_pattern) requires that "Observers" register with the subject, which then pushes notifications to all registered observers when an event occurs.
- [ ] - good simple [overview](https://struchkov.dev/blog/ru/overview-of-reactive-programming/) about reactive programming and reactive systems
- [ ] - Reactive Streams under-hood ([video](https://www.youtube.com/watch?v=qmuNAWKNJWs))
- [ ] - Java Reactive Streams and Java Stream API
- [ ] - [Spring WebFlux vs Node.js perfomance compare](https://community.sap.com/t5/technology-blogs-by-members/spring-boot-reactive-vs-node-js-in-sap-cloud-platform-reflection-on/ba-p/13374735)
- ![[spring-webflux-vs-node-js-perfomance-compare.png]]
- 1, 5, 10, 20, 30, 40, 50 users - 1000 requests/user loop
- [ ] - [Advance](https://medium.com/@manikmudholkar831995/async-io-in-nodejs-a57fe9c3ccc6) Node.js Async IO explanation 
- [ ] - Node.js Event Loop use polling OS mechanisms (`epoll()`/`iocp()`/`kqueue()`)
- [ ] - Node.js Event Loop [responsible for non-blocking I/O](https://nodejs.org/en/learn/asynchronous-work/dont-block-the-event-loop#:~:text=Event%20Loop%20is%20responsible%20for%20JavaScript%20callbacks%20and%20non%2Dblocking%20I/O) not a Worker Thread - libuv?
- [ ] - [On low level R2DBC uses Netty](https://piotrd.hashnode.dev/javas-reactive-connection-pooling-performance-caveat#:~:text=R2DBC%20handles%20database%20interaction%2C%20but%20at%20the%20low%2Dlevel%20it%20uses%20netty.%20Netty%20is%20a%20real%20%22reactivity%22%20enabler%20here.)?
- [ ] - Without reactive drivers for DB, Network, Queues, Kafka etc. cannot be non-blocking processes